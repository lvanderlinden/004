# Generated by OpenSesame 0.27~rc2 (Frisky Freud)
# Mon Dec 17 17:16:47 2012 (posix)
# <http://www.cogsci.nl/opensesame>

set foreground "black"
set subject_parity "even"
set font_size "18"
set description "An affordances/ orientation effect type of experiment (cf. Symes et al. 2005, Vis Cog)"
set title "Orientation effect"
set font_family "mono"
set font_bold "no"
set coordinates "relative"
set height "768"
set mouse_backend "psycho"
set width "1024"
set compensation "0"
set sampler_backend "legacy"
set keyboard_backend "psycho"
set background "white"
set subject_nr "0"
set canvas_backend "psycho"
set start "experiment"
set synth_backend "legacy"
set font_italic "no"

define inline_script extra_log_vars
	set _run ""
	___prepare__
	"""
	DESCRIPTION:
	In this inline script some extra log files are defined, such
	as global variables which may be changed during the process of 
	designing an experiment. By logging even the default variables
	I will never have to doubt about what exact values I used for
	this and that run.
	"""
	__end__
	set description "Executes Python code"

define srbox continue_after_block_feedback
	set dev "COM4"
	set description "Collects input from a serial response box (Psychology Software Tools) or compatible devices"
	set timeout "infinite"
	set _dummy "no"

define feedback feedback
	set duration "keypress"
	set reset_variables "yes"
	set description "Provides feedback to the participant"
	draw textline -160 -256 "[correct_response]" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always"

define sequence sequence
	set flush_keyboard "yes"
	set description "Runs a number of items in sequence"
	run practice_instructions_english "[language] = English"
	run practice_instructions_french "[language] = French"
	run continue_after_practice "always"
	run get_block_properties "always"
	run reset_feedback "always"
	run practice_trials "always"
	run practice_feedback_french "[language] = French"
	run practice_feedback_english "[language] = English"

define feedback feedback_english
	set duration "0"
	set reset_variables "yes"
	set description "Provides feedback to the participant"
	draw textline 0 -64 "Your average response time was [avg_rt]ms" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always"
	draw textline 0 0 "Your accuracy was [acc]%" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always"
	draw textline 0 170 "You can take a short break" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always"
	draw textline 0 230 "Press a key to continue" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always"
	draw textline 0 64 "Try to keep your accuracy above [cutoff]%" center=1 color=#f57900 font_family="mono" font_size=18 font_italic=no font_bold=yes show_if="=self.get('acc') < self.get('cutoff')"
	draw textline 0 -128 "End of block [blockNr]/[block_total]" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always"

define eyelink_start_recording eyelink_start_recording
	set description "Start recording plugin for the Eyelink series of eye trackers (SR-Research)"
	set log_msg "start_trial [count_trial_sequence]"

define inline_script display_fixation_and_stimulus
	___run__
	"""
	DESCRIPTION:
	Shows prepared stimuli for a given duration:
	"""
	
	# Draw everything to the canvas, show, and wait for response
	# (with keyboard response)
	
	# Fixation dot:
	fixdot.draw()
	fixdot_inner_circle.draw()
	win.flip()
	self.experiment.eyelink.log("display fixation")
	self.sleep(jitter)
	
	
		
	if eyetracking:
		# Check for fixation:
		i = 0
		nr_samples = 0
		
	#	if pict == "catch_trial":
	#		min_samples_fix = catch_dur
		
		while True:
			x_sample, y_sample = self.experiment.eyelink.sample()
			nr_samples +=1
			dev = abs(y_sample - y_fix_normal)
			
			print "i = ",i
			print "sample = ", y_sample
			print "deviation = ", dev
			print "y_fix = ", y_fix
			
			if dev < max_dev_fix:
				i +=1
			else:
				i = 0
				if dev > dev_for_warning:
					my_sampler.play()
					self.experiment.eyelink.log("warning sound played")
			if i == min_samples_fix:
				self.experiment.eyelink.log("fixation on fixdot check successfull")
				# TODO: if it was a catch trial: winning sound
				break
			if nr_samples == max_samples:
				self.experiment.eyelink.log("fixation on fixdot check failed for %s samples in a row" % max_samples)
				break
				
	
	# Fixation dot + stimulus
	# Draw stimulus on in gap overlap condition:
	if gap == "overlap":
		#win.flip()
		#self.sleep(100)
		fixdot_large.draw()
		fixdot_inner_circle.draw()
	stim.draw()
	win.flip()
	self.experiment.eyelink.log("display stimulus")
	
	if eyetracking:
	
		#if pict != "catch_trial":
	
		
		# Check for fixation:
		i = 0
		nr_samples = 0
	
		while True:
	
			x_sample, y_sample = self.experiment.eyelink.sample()
			nr_samples +=1
			dev = abs(y_sample - y_object_normal)
			
			print "i = ",i
			print "sample = ", y_sample
			print "deviation = ", dev
			print "y_object = ", y_object_normal
	
		
		
			if dev < max_dev_object:
				i +=1
			else:
				i = 0
			if i == min_samples_object:
				self.experiment.eyelink.log("fixation on object check successfull")
				break
			if nr_samples == max_samples:
				self.experiment.eyelink.log("fixation on object check failed for %s samples in a row" % max_samples)
				break
	__end__
	___prepare__
	"""
	DESCRIPTION:
	Here the display is prepared. 
	The stimulus has two important properties. The texture (tex) is the stimulus
	itself, which is in this case a PIL Image. The mask is an array
	that indicates the transparency of the stimulus, where -1 is transparent and 1
	is opaque. The mask has to be a 2D numpy array. Because here there is only a
	gradient in one direction, the first dimension is only 1 (so it's basically a 1D
	array).
	"""
	
	from openexp.sampler import sampler
	from psychopy.visual import ImageStim, GratingStim
	from PIL import Image
	
	from openexp.canvas import canvas
	my_canvas = canvas(exp)
	
	# SAMPLER:
	global my_sampler
	my_sampler = sampler(self.experiment, self.experiment.get_file("wrong.ogg"))
	
	# RANDOM Y POSITION:
	# Determine y coordinate for the stimulus (random within
	# a certain range):
	y_stim = random.randint(y_stim_min, y_stim_max)
	#y_stim = y_stim_max
	if visual_field == "lower":
		y_stim = -y_stim
	exp.set("y_stim", y_stim)
	
	# Determine visual degrees relative to center:
	y_stim_degrees = toDegr(y_stim)
	exp.set("y_stim_degrees", y_stim_degrees)
	
	global y_object_normal
	y_object_normal = y_cen - y_stim
	
	# Determine jitter in fixation dot duration:
	global jitter
	jitter = 250+random.gauss(200, 50)
	exp.set("jitter", jitter)
	
	# Create an Image using PIL
	# http://www.pythonware.com/library/pil/handbook/image.htm
	path = exp.get_file("%s.jpg"%pict)
	tex = Image.open(path)
	if self.get("handle_side") == "left":
		tex = tex.transpose(Image.FLIP_LEFT_RIGHT)
	
	# Create the mask
	# http://www.psychopy.org/api/visual/gratingstim.html
	
	# NOTE:
	# If mask side is right, the left part of the object has more contrast:
	
	mask = np.empty( (1, mask_width) )
	if self.get('mask_side') == "left":
		mask[0] = np.linspace(max_transp, min_transp, mask_width)
	if self.get('mask_side') == "right":
		mask[0] = np.linspace(min_transp, max_transp, mask_width)
	if self.get('mask_side') == "control" or self.get('pict') == 'catch_trial':
		mask[0] = np.linspace(min_transp, min_transp, mask_width)
	
	# Create the stim
	global stim
	if scale_stim:
		size = (scaled_width, scaled_height)
	else:
		size = None
	stim = GratingStim(win, tex=tex, mask=mask, pos=(x_stim,y_stim),size = size)
	
	# Fixation dot (inner and outer circle!)
	global fixdot, fixdot_inner_circle,fixdot_large
	fixdot= GratingStim(win, tex=None, mask='circle', size=16,color='black', pos = (x_fix, y_fix))
	fixdot_inner_circle = GratingStim(win, tex=None, mask='circle', size = 4, color='white', pos = (x_fix, y_fix))
	fixdot_large = GratingStim(win, tex=None, mask='circle', size=large_fix_size,color=large_fix_col, pos = (x_fix, y_fix))
	__end__
	set description "Executes Python code"

define loop block_loop
	set repeat "0.02"
	set description "A single block of trials"
	set skip "0"
	set offset "no"
	set item "trial_sequence"
	set column_order ""
	set cycles "96"
	set order "sequential"
	run trial_sequence

define sketchpad red_fixation
	set duration "[feedback_dur]"
	set description "Displays stimuli"
	set start_response_interval "no"
	draw fixdot 0 [y_fix] color=red show_if="always"

define feedback _feedback
	set duration "keypress"
	set reset_variables "yes"
	set description "Provides feedback to the participant"
	draw textline -64 -256 "[response]" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always"
	draw textline -96 -96 "[correct]" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always"

define feedback feedback_french
	set duration "0"
	set reset_variables "yes"
	set description "Provides feedback to the participant"
	draw textline 0 -64 "Votre temps de rU+00E9ponse moyen U+00E9tait de [avg_rt]ms" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always"
	draw textline 0 0 "Votre pourcentage de rU+00E9ponse correcte U+00E9tait de [acc]%" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always"
	draw textline 0 170 "Vous pouvez prendre une petite pause" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always"
	draw textline 0 230 "Appuyez sur un bouton pour continuer" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always"
	draw textline 0 64 "Svp, pour la suite de l'expU+00E9rience" center=1 color=#f57900 font_family="mono" font_size=18 font_italic=no font_bold=yes show_if="=self.get('acc') < self.get('cutoff')"
	draw textline 0 110 "essayez d'obtenir un pourcentage supU+00E9rieur U+00E0 [cutoff]%" center=1 color=#f57900 font_family="mono" font_size=18 font_italic=no font_bold=yes show_if="=self.get('acc') < self.get('cutoff')"
	draw textline 0 -128 "Fin de bloc [blockNr]/[block_total]" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always"
	draw rect 0 96 0 0 fill=0 penwidth=1 color=black show_if="always"

define inline_script inline_script
	set _run ""
	set _prepare ""
	set description "Executes Python code"

define feedback __feedback
	set duration "keypress"
	set reset_variables "yes"
	set description "Provides feedback to the participant"
	draw textline 0 -64 "Votre temps de rU+00E9ponse moyen U+00E9tait de [avg_rt]ms" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always"
	draw textline 0 0 "Votre pourcentage de rU+00E9ponse correcte U+00E9tait de [acc]%" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always"
	draw textline 0 170 "Vous pouvez prendre une petite pause" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always"
	draw textline 0 230 "Appuyez une pour continuer" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always"
	draw textline 0 64 "Svp, pour la suite de l'expU+00E9rience" center=1 color=#f57900 font_family="mono" font_size=18 font_italic=no font_bold=yes show_if="=self.get('acc') < self.get('cutoff')"
	draw textline 0 128 "essayez d'obtenir un pourcentage supU+00E9rieur U+00E0 [cutoff]%" center=1 color=#f57900 font_family="mono" font_size=18 font_italic=no font_bold=yes show_if="=self.get('acc') < self.get('cutoff')"

define form_consent form_consent_english
	set accept_text "Participate!"
	set rows "1;4;1;1"
	set description "A simple consent form"
	set checkbox_text "I have read and understood the information shown above"
	__form_text__
	You are about to participate in an experiment.
	
	This experiment poses no known risks to your health and your name will not be associated with the findings.
	
	If you have any questions not addressed by this consent form, please do not hesitate to ask.
	
	You can stop at any time during experiment if you feel uncomfortable.
	__end__
	set form_title "<span size=24>Consent form</span>"
	set decline_text "Do not participate"
	set decline_message "You need to accept the consent form to participate!"
	widget 0 0 2 1 label text="[form_title]"
	widget 0 1 2 1 label center="no" text="[form_text]"
	widget 0 2 2 1 checkbox var="checkbox_status" text="[checkbox_text]"
	widget 0 3 1 1 button var="accept_status" text="[accept_text]"
	widget 1 3 1 1 button text="[decline_text]"


define eyelink_stop_recording eyelink_stop_recording

define inline_script get_block_properties
	set _run ""
	___prepare__
	"""
	DESCRIPTION:
	Read the pseudorandomized trial lists (as returned by Mix)
	from the file pool. 
	
	NOTE:
	Do this again for every participant!
	"""
	
	# GAP LIST:
	global gap_list
	gap_list = ["zero", "overlap"] * (trials_per_block/2)
	random.shuffle(gap_list)
	
	# VISUAL FIELD LIST:
	global vf_list
	vf_list = ["upper", "lower"] * (trials_per_block/2)
	random.shuffle(vf_list)
	
	# TRIAL LIST:
	global blockNr
	if self.get("practice") == "no":
	
		# Determine the block count:
		blockNr = self.get("count_get_block_properties")+1
		exp.set("blockNr", blockNr)
	
		# Determine the relevant file:
		path = exp.get_file('block_list%s.txt'%blockNr)
	
	if self.get("practice") == "yes":
		
		# Open a random file:
		path = exp.get_file('block_list%s.txt'%random.choice(range(1,7)))
		
		# Reset the block counter:
		exp.items['get_block_properties'].count = 0
		
	# Open the file for reading:
	f = open(path, 'r')
	
	# Store the objects in a list:
	global trial_list, work_list
	
	trial_list = []
	
	for obj in f:
		obj = obj.strip()
		trial_list.append(obj)
	
	if catch:
		# Add catch trials:
		for i in range(nr_catch):
			random_index = random.randint(1, trials_per_block)
			trial_list.insert(random_index,'catch_trial')
	
	# Get the to-be-popped-from trial list:
	work_list = copy.deepcopy(trial_list)
		
	# LSD ARRAY AND CONDITION KEYS:
	
	# Get the array:
	global array
	if self.get("practice") == "no":
	
		# Otherwise the parameter blockNr is unknown
		array = getLSD(blockNr=blockNr)	
	
	# Get the dictionary:
	global letter_dict
	letter_dict = getDict()
	__end__
	set description "Executes Python code"

define form_text_display practice_instructions_french
	set rows "1;4;1"
	set description "A simple text display form"
	set cols "1;1;1"
	__form_text__
	Rappelez-vous:
	
	- Si l'objet appartient U+00E0 la cuisine: appuyez sur [correct_kitchen_label]
	- Si l'objet appartient au garage: appuyez sur [correct_garage_label]
	
	PrU+00EAt?
	
	Appuyez sur un bouton pour continuer...
	__end__
	set only_render "yes"
	set form_title "<span size=24>Title</span>"
	set ok_text "Ok"
	widget 0 1 3 1 label center="no" text="[form_text]"


define loop experimental_loop
	set repeat "1"
	set description "Repeatedly runs another item"
	set skip "0"
	set offset "no"
	set item "block_sequence"
	set column_order "correct_kitchen;correct_garage;practice;correct_kitchen_label;correct_garage_label"
	set cycles "6"
	set order "sequential"
	setcycle 0 correct_kitchen "[response1]"
	setcycle 0 correct_kitchen_label "[label1]"
	setcycle 0 practice "no"
	setcycle 0 correct_garage "[response2]"
	setcycle 0 correct_garage_label "[label2]"
	setcycle 1 correct_kitchen "[response1]"
	setcycle 1 correct_kitchen_label "[label1]"
	setcycle 1 practice "no"
	setcycle 1 correct_garage "[response2]"
	setcycle 1 correct_garage_label "[label2]"
	setcycle 2 correct_kitchen "[response1]"
	setcycle 2 correct_kitchen_label "[label1]"
	setcycle 2 practice "no"
	setcycle 2 correct_garage "[response2]"
	setcycle 2 correct_garage_label "[label2]"
	setcycle 3 correct_kitchen "[response2]"
	setcycle 3 correct_kitchen_label "[label2]"
	setcycle 3 practice "no"
	setcycle 3 correct_garage "[response1]"
	setcycle 3 correct_garage_label "[label1]"
	setcycle 4 correct_kitchen "[response2]"
	setcycle 4 correct_kitchen_label "[label2]"
	setcycle 4 practice "no"
	setcycle 4 correct_garage "[response1]"
	setcycle 4 correct_garage_label "[label1]"
	setcycle 5 correct_kitchen "[response2]"
	setcycle 5 correct_kitchen_label "[label2]"
	setcycle 5 practice "no"
	setcycle 5 correct_garage "[response1]"
	setcycle 5 correct_garage_label "[label1]"
	run block_sequence

define sequence experiment
	run TODO "always"
	run global_functions "always"
	run global_variables "always"
	run suppress_warnings "always"
	run main_instructions "always"
	run eyelink_calibrate "always"
	run practice_loop "always"
	run experimental_loop "always"
	run goodbye "always"

define sketchpad main_instructions
	set duration "keypress"
	set description "Displays stimuli"
	draw image 0 0 "[language]_instructions_[subject_parity].png" scale=1 center=1 show_if="always"

define logger logger
	set description "Logs experimental data"

define feedback practice_feedback_english
	set duration "0"
	set reset_variables "yes"
	set description "Provides feedback to the participant"
	draw textline 0 -64 "Your average response time was [avg_rt]ms" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always"
	draw textline 0 0 "Your accuracy was [acc]%" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always"
	draw textline 0 230 "Press a key to continue" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always"
	draw textline 0 160 "Are you ready for the experiment?" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always"
	draw textline 0 -160 "End of the practice trials" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always"

define loop practice_loop
	set repeat "1"
	set description "Repeatedly runs another item"
	set skip "0"
	set offset "no"
	set item "sequence"
	set column_order "correct_kitchen;correct_garage;practice;correct_kitchen_label;correct_garage_label"
	set cycles "1"
	set order "random"
	setcycle 0 correct_kitchen "[response1]"
	setcycle 0 correct_kitchen_label "[label1]"
	setcycle 0 practice "yes"
	setcycle 0 correct_garage "[response2]"
	setcycle 0 correct_garage_label "[label2]"
	run sequence

define feedback practice_feedback_french
	set duration "0"
	set reset_variables "yes"
	set description "Provides feedback to the participant"
	draw textline 0 -64 "Votre temps de rU+00E9ponse moyen U+00E9tait de [avg_rt]ms" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always"
	draw textline 0 0 "Votre pourcentage de bonne rU+00E9ponse U+00E9tait de [acc]%" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always"
	draw textline 0 230 "Appuyez sur un bouton pour commencer l'expU+00E9rience..." center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always"
	draw textline 0 160 "PrU+00EAt?" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always"
	draw textline 0 -160 "Fin de la phase pratique" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always"

define form_text_display block_instructions_french
	set rows "1;4;1"
	set description "A simple text display form"
	set cols "1;1;1"
	__form_text__
	Tu es U+00E0 la moitiU+00E9 de l'expU+00E9rience.
	
	Pour les trois derniers blocs, les boutons rU+00E9ponses vont U+00EAtre inversU+00E9s. Donc:
	
	- Si l'objet appartient U+00E0 la cuisine: appuyez [correct_kitchen_label]
	- Si l'objet appartient au garage: appuyez [correct_garage_label]
	
	PrU+00EAt?
	
	Appuyez sur un bouton pour continuer ...
	__end__
	set only_render "yes"
	set form_title "<span size=24>Title</span>"
	set ok_text "Ok"
	widget 0 1 3 1 label center="no" text="[form_text]"


define inline_script global_functions
	set _run ""
	___prepare__
	"""
	DESCRIPTION:
	Create a matrix containing letters A-F (referring to the 6 conditions)
	by blocking both repetition and object.
	"""
	
	# Import Python modules:
	global np, collections, itertools, random, copy, os
	import numpy as np
	import collections
	import itertools
	import random
	import copy
	import os
	
	# TO DO: check for fixation on catch trials!
	exp.set("fix_lost", 'no')
	
	# Define constants:
	global handleCond, maskCond, condList, repList, letterList, pictList
	
	handleCond = ["handle_left", "handle_right"]
	maskCond = ["mask_left", "mask_right", "mask_control"]
	condList = list(itertools.product(handleCond, maskCond))
	
	repList = [0,1,2,3,4,5,6]
	letterList = collections.deque(['A','B','C','D','E','F'])
	pictList =	["symm_garage_leveller", "asymm_kitchen_spoon2", "symm_garage_ruler", "asymm_kitchen_spoon", "asymm_garage_chisel", "symm_kitchen_carrot", "asymm_kitchen_sharpeningsteel", "asymm_garage_wrench", "asymm_kitchen_washingbrush", "asymm_garage_screwdriver", 	"symm_kitchen_roller", "asymm_kitchen_knife", "asymm_kitchen_peeler", "asymm_garage_hammer", "asymm_garage_mallet", "asymm_kitchen_fork", "asymm_garage_paintbrush", "asymm_garage_chisel2"]
	
	#allPictures = pictList * len(condList)
	#for obj in allPictures:
	#	print obj
	#sys.exit()
	
	global toPix, toDegr
	
	def toPix(degr, ratio = 34):
		
		"""
		Converts visual degrees to pixels.
		
		Arguments:
		degr	--- distance in visual degrees
		
		Keyword arguments:
		ratio	--- ratio between pixels and degrees (default=34)
		
		Returns:
		corresponding number of pixels
		
		TODO: check the exact ratio!
		"""
		
		pix = degr * ratio
		
		return pix
		
	def toDegr(pix, ratio = 34):
	
		"""
		Converts pixels to visual degrees.
		
		Arguments:
		pix		--- number of pixels
		
		Keyword arguments:
		ratio	--- ratio between pixels and degrees (default=34)
		
		Returns:
		corresponding number of visual degrees
		"""
		
		degr = pix / ratio
		
		return degr
		
	
	global getLSD
	
	def getLSD(blockNr=1):
		
		"""
		Create array according to the constraints of a Latin Square Design:
		
		Arguments:
		blockNr	--- int indicating block number. This is to make sure that for
					every subsequent block the letters are shifted one cell to the
					right.
		
		Returns:
		array 	--- containing repetition in columns and objects in rows
					filled with conditions according to LSD procedure
		"""
		
		# Convert blockNr to int:
		blockNr = int(blockNr)
		
		# Shuffle the picture list:
		random.shuffle(pictList)
	
		array = np.zeros((19,7),dtype = '|S100')
		
		_letterList = copy.deepcopy(letterList)
		_letterList.rotate(-1*blockNr+1)
	
		array[0] = repList
		index = 0
		for i in range(len(pictList)):
			col = i +1
			index +=1
			print "!!!!!!!!!!!!!!!!!!!!!!!!!!"
			print array
			array[col,0] = pictList[i]
			array[col,1:] = list(_letterList)
			_letterList.rotate(-1)
			if index in range(6,25,6):
				index = 0
		
		return array
	
		
	global getDict
	def getDict():
		
		"""
		Create dictionary where the identifiers A to F refer to a randomly picked
		condition.
		
		returns:
		randomDict --- with identifier (A-F) as key and corresponding to condition as value
		"""
		
		# Shuffle the list:
		random.shuffle(condList)
		
		# Make a dictionary:
		randomDict = {}
		
		for i in range(len(condList)):
			randomDict[letterList[i]] = condList[i]
		
		return randomDict
	
	# SET LOG VARS to None:
	# Because on catch trials do not have much trial information (such as cat etc):
	global setNones
	
	def setNones():
	
		"""
		Function to set trial properties such as category to None in case of catch trial:
		"""
		
		cat = symm = object = rep = handle_side = mask_side = response_hand = aff_lum = comp = None
	__end__
	set description "Executes Python code"

define srbox continue_after_practice_feedback
	set dev "COM4"
	set description "Collects input from a serial response box (Psychology Software Tools) or compatible devices"
	set timeout "infinite"
	set _dummy "no"

define inline_script response_msg
	___run__
	# Send a message to the eye link indicating that
	# a response has been collected.
	self.experiment.eyelink.log("response given = %s"%self.get("response"))
	__end__
	set _prepare ""
	set description "Executes Python code"

define loop practice_trials
	set repeat "1"
	set description "Repeatedly runs another item"
	set skip "0"
	set offset "no"
	set item "practice_sequence"
	set column_order ""
	set cycles "10"
	set order "random"
	run practice_sequence

define inline_script determine_practice_trials
	set _run ""
	___prepare__
	"""
	DESCRIPTION:
	Here the properties for the practice trials are randomly selected.
	"""
	
	# Set count_trial_sequence to 0
	exp.set("count_trial_sequence", 0)
	exp.set("count_block_loop", 0)
	exp.set("cond", "practice")
	exp.set("rep", "practice")
	exp.set("letter", "practice")
	exp.set("overall_rep", "practice")
	
	# GET OBJECT:
	# Determine the picture for the current trial:
	global pict
	pict = random.choice(work_list)
	exp.set("pict", pict)
	
	# GET NAME INFO:
	# Picture names contain some trial info:
	global symm, cat, object
	
	if pict == "catch_trial":
		symm = cat = object = None
		catch_trial = "yes"
		
	if pict != "catch_trial":
		catch_trial = "no"
		var_list = os.path.splitext(pict)[0]
		var_list = var_list.split("_")
		symm = var_list[0]
		cat = var_list[1]
		object = var_list[2]
	
	# GET CONDITION:
	global cond, handle_side, mask_side
	
	if pict == "catch_trial":
	
		cond = handle_side = mask_side = None
	
	if pict != "catch_trial":
	
		# Randomly determine condition:
	
		handle_side = random.choice(["left", "right"])
		mask_side = random.choice(["left", "right"])
	
	exp.set("handle_side", handle_side)
	exp.set("mask_side", mask_side)
	
	# GET RESPONSE:
	global correct
	
	if pict == "catch_trial":
		correct = None
	
	if pict != "catch_trial":
		if cat == "kitchen":
			correct = self.get("correct_kitchen")
		if cat == "garage":
			correct = self.get("correct_garage")
	
	# Set correct response:
	exp.set("correct_response", correct)
	
	# GET MORE TRIAL INFO:
	# Some more to-be-logged trial info:
	
	global response_hand, comp, aff_lum
	
	if pict == "catch_trial":
		response_hand =comp= aff_lum = None
		
	if pict != "catch_trial":
	
		# Compatibility of response hand and object orientation:
		if self.get("correct_response") == left_button:
			response_hand = "left"
		if self.get("correct_response") == right_button:
			response_hand = "right"
		if response_hand == self.get("handle_side"):
			comp = "compatible"
		else:
			comp = "incompatible"
	
		# Determine whether luminant side and affording side overlap:
		if mask_side == "control":
			aff_lum = "control"
		elif mask_side == handle_side:
			# e.g. when handle is on the left, but mask is also on the left
			aff_lum = "opposite"
		elif mask_side != handle_side:
			# e.g. when handle is on the left and mask on the right.
			# in this case the affording side is also the side with the most
			# contrast:
			aff_lum = "overlap"
	
	# GET VISUAL FIELD:
	global visual_field
	if pict != "catch_trial":
		visual_field = random.choice(["upper", "lower"])
	else:
		visual_field = None
	
	exp.set("visual_field", visual_field)
	
	
	# GET GAP:
	# Determine gap condition:
	global gap
	if pict != "catch_trial":
		gap = random.choice(["zero", "overlap"])
	else:
		gap = "overlap"
		
	# SET all variables:
	exp.set("symm", symm)
	exp.set("cat", cat)
	exp.set("object", object)
	exp.set("response_hand", response_hand)
	exp.set("comp", comp)
	exp.set("aff_lum", aff_lum)
	exp.set("catch_trial", catch_trial)
	exp.set("gap", gap)
	
	
	if pict != "catch_trial":
		print "handle = ", handle_side
		print "mask = ", mask_side
		print "gap = ", gap
		print "cat = ", cat
		print "symm = ", symm
		print "hand = ", response_hand
		print "comp = ", comp
		print "aff_lum = ", aff_lum
	__end__
	set description "Executes Python code"

define sketchpad green_fixation
	set duration "[feedback_dur]"
	set description "Displays stimuli"
	set start_response_interval "no"
	draw fixdot 0 [y_fix] color=green show_if="always"

define eyelink_log eyelink_log
	__msg__
	var object [object]
	var mask_side [mask_side]
	var handle_side [handle_side]
	var response_hand [response_hand]
	var comp [comp]
	var aff_lum [aff_lum]
	var cat [cat]
	var y_stim [y_stim]
	var accuracy [correct]
	var correct_response [correct_response]
	var RT [response_time]
	var block_count [count_block_loop]
	var trial_count [count_trial_sequence]
	var subject_parity [subject_parity]
	var jitter_dur [jitter]
	var gap [gap]
	var cutoff_warning_msg [cutoff]
	var scale_item [scale_stim]
	var scale [scale]
	var scaled_width [scaled_width]
	var scaled_height [scaled_height]
	var picture_name [pict]
	var cond [cond]
	var rep [rep]
	var handle_side [handle_side]
	var mask_side [mask_side]
	var latin_square_letter [letter]
	var symm [symm]
	var max_dev_fix [max_dev_fix]
	var min_samples_fix [min_samples_fix]
	var max_dev_object [max_dev_object]
	var min_samples_object [min_samples_object]
	var max_samples [max_samples]
	var dev_for_warning [dev_for_warning]
	var catch_trial [catch_trial]
	var visual_field [visual_field]
	var overall_rep [overall_rep]
	var large_fix_size [large_fix_size]
	var large_fix_col [large_fix_col]
	var y_stim_degrees [y_stim_degrees]
	__end__
	set description "Message log for the Eyelink series of eye trackers (SR-Research)"

define sequence trial_sequence
	set description "A single trial"
	run get_trial_properties "always"
	run eyelink_drift_correct "always"
	run eyelink_start_recording "always"
	run display_fixation_and_stimulus "always"
	run srbox "always"
	run response_msg "always"
	run green_fixation "[correct] = 1 and [pict] != 'catch_trial'"
	run red_fixation "[correct] = 0 and [pict] != 'catch_trial'"
	run extra_log_vars "always"
	run logger "always"
	run eyelink_log "always"
	run eyelink_stop_recording "always"

define form_text_display practice_instructions_english
	set rows "1;4;1"
	set description "A simple text display form"
	set cols "1;1;1"
	__form_text__
	Remember:
	
	- If the object belongs in the kitchen: press [correct_kitchen_label]
	- If the object belongs in the garage: press [correct_garage_label]
	
	Ready?
	
	Press any key to start the practice trials...
	__end__
	set only_render "yes"
	set form_title "<span size=24>Title</span>"
	set ok_text "Ok"
	widget 0 1 3 1 label center="no" text="[form_text]"


define sequence practice_sequence
	set flush_keyboard "yes"
	set description "Runs a number of items in sequence"
	run determine_practice_trials "always"
	run eyelink_drift_correct "always"
	run eyelink_start_recording "always"
	run display_fixation_and_stimulus "always"
	run srbox "always"
	run response_msg "always"
	run green_fixation "[correct] = 1"
	run red_fixation "[correct] = 0"
	run logger "always"
	run eyelink_log "always"
	run eyelink_stop_recording "always"
	run continue_after_practice_feedback "always"

define srbox continue_after_block
	set timeout "infinite"
	set description "Collects input from a serial response box (Psychology Software Tools) or compatible devices"
	set dev "COM4"
	set _dummy "no"

define notepad TODO
	__note__
	rnTime duration with everything included.
	Response devices - Delphine's response device or Sebastiaans button box?
	Checks for fixation - If you LOOKED at the object long enough (but not anymore), you CAN respond
	Smileys
	Font veranderen
	Forms:
	- Consent -> French, twee tegelijk gaat niet..?
	- Brief questionnaire -> in excel sheet
	Warning sound!
	__end__
	set description "A simple notepad to document your experiment. This plug-in does nothing."

define form_text_display block_instructions_english
	set rows "1;4;1"
	set description "A simple text display form"
	set cols "1;1;1"
	__form_text__
	You are now half-way through the experiment.
	
	For the last three blocks, please swap your response rule, such that:
	
	- If the object belongs in the kitchen: press [correct_kitchen_label]
	- If the object belongs in the garage: press [correct_garage_label]
	
	Ready?
	
	Press any key to continue...
	__end__
	set only_render "yes"
	set form_title "<span size=24>Title</span>"
	set ok_text "Ok"
	widget 0 1 3 1 label center="no" text="[form_text]"


define sketchpad sketchpad

define sequence block_sequence
	set description "A sequence containging a single block of trials followed by feedback to the participant"
	run get_block_properties "always"
	run block_instructions_english "[language] = English and [blockNr] = 4"
	run block_instructions_french "[language] = French and [blockNr] = 4"
	run continue_after_block "always"
	run reset_feedback "always"
	run block_loop "always"
	run feedback_french "[language] = French"
	run feedback_english "[language] = English"
	run continue_after_block_feedback "always"

define inline_script get_trial_properties
	set _run ""
	___prepare__
	"""
	DESCRIPTION:
	Here the properties of the current trial are determined.
	Firstly, the letter in the LSD-matrix corresponding to a
	given object for a given repetition is determined.
	Next, the condition randomly assigned to this letter is
	determined (same ACROSS ALL BLOCKS?)
	"""
	
	# GET OBJECT:
	# Determine the picture for the current trial:
	global pict
	pict = work_list.pop()
	exp.set("pict", pict)
	
	# GET NAME INFO:
	# Picture names contain some trial info:
	global symm, cat, object
	
	if pict == "catch_trial":
		symm = cat = object = None
		catch_trial = "yes"
		
	if pict != "catch_trial":
		catch_trial = "no"
		var_list = os.path.splitext(pict)[0]
		var_list = var_list.split("_")
		symm = var_list[0]
		cat = var_list[1]
		object = var_list[2]
	
	
	# GET REPETITION:
	global rep
	
	if pict == "catch_trial":
		rep = None
	if pict != "catch_trial":
		# Make a dictionary for counting the repetitions:
		rep_count = {} 
	
		# First set all values in the dictionary to 0:
		for i in trial_list:
			rep_count[i] = 0
	
		# Determine the repetition:
		for i in work_list:
			rep_count[i] = rep_count.get(i, 0) + 1
			rep = 6 - (rep_count[pict])
	exp.set("rep", rep)
	
	# OVERALL REP:
	# Determine how many times a given object has already been
	# presented OVER blocks:
	
	global overall_rep
	
	# First, add the current object to the list containing all
	# shown objects:
	shown_objects.append(object)
	
	# Count the occurrence of the object in the list.
	# NOTE: count() starts with 1
	overall_rep = shown_objects.count(object)
	exp.set("overall_rep", overall_rep)
	
	
	
	
	
	# GET LETTER FROM LSD:
	global letter
	
	if pict == "catch_trial":
		letter = None
	if pict != "catch_trial":
		# Look up the letter in the cell corresponding to column = rep, row = picture:
		for _a in array:
			if pict == _a[0]:
				letter = _a[rep]
				break
			else:
				print "%s is not a row header"%pict
		
	exp.set("letter", letter)		
	
	# GET CONDITION:
	global cond, handle_side, mask_side
	
	if pict == "catch_trial":
	
		cond = handle_side = mask_side = None
	
	if pict != "catch_trial":
	
		# Look up the condition assigned to the letter:
	
		cond = letter_dict[letter]
		handle_side = cond[0].split("_")[1]
		mask_side = cond[1].split("_")[1]
	
	exp.set("cond", cond)
	exp.set("handle_side", handle_side)
	exp.set("mask_side", mask_side)
	
	# GET RESPONSE:
	global correct
	
	if pict == "catch_trial":
		correct = None
	
	if pict != "catch_trial":
		if cat == "kitchen":
			correct = self.get("correct_kitchen")
		if cat == "garage":
			correct = self.get("correct_garage")
	
		# Set correct response:
	exp.set("correct_response", correct)
	
	# GET MORE TRIAL INFO:
	# Some more to-be-logged trial info:
	
	global response_hand, comp, aff_lum
	
	if pict == "catch_trial":
		response_hand =comp= aff_lum = None
		
	if pict != "catch_trial":
	
		# Compatibility of response hand and object orientation:
		if self.get("correct_response") == left_button:
			response_hand = "left"
		if self.get("correct_response") == right_button:
			response_hand = "right"
		if response_hand == self.get("handle_side"):
			comp = "compatible"
		else:
			comp = "incompatible"
	
		# Determine whether luminant side and affording side overlap:
		if mask_side == "control":
			aff_lum = "control"
		elif mask_side == handle_side:
			# e.g. when handle is on the left, but mask is also on the left
			aff_lum = "opposite"
		elif mask_side != handle_side:
			# e.g. when handle is on the left and mask on the right.
			# in this case the affording side is also the side with the most
			# contrast:
			aff_lum = "overlap"
	
	# GET VISUAL FIELD:
	global visual_field
	if pict != "catch_trial":
		visual_field = vf_list.pop()
	else:
		visual_field = None
	
	exp.set("visual_field", visual_field)
	
	
	# GET GAP:
	# Determine gap condition:
	global gap
	if pict != "catch_trial":
		gap = gap_list.pop()
	else:
		gap = "overlap"
		
	# SET all variables:
	exp.set("symm", symm)
	exp.set("cat", cat)
	exp.set("object", object)
	exp.set("response_hand", response_hand)
	exp.set("comp", comp)
	exp.set("aff_lum", aff_lum)
	exp.set("catch_trial", catch_trial)
	exp.set("gap", gap)
	
	
	if pict != "catch_trial":
		print "handle = ", handle_side
		print "mask = ", mask_side
		print "gap = ", gap
		print "cat = ", cat
		print "symm = ", symm
		print "hand = ", response_hand
		print "comp = ", comp
		print "aff_lum = ", aff_lum
	__end__
	set description "Executes Python code"

define keyboard_response __keyboard_response

define feedback ___feedback
	set duration "keypress"
	set reset_variables "yes"
	set description "Provides feedback to the participant"
	draw textline 0 -64 "Votre temps de rU+00E9ponse moyen U+00E9tait de [avg_rt]ms" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always"
	draw textline 0 0 "Votre pourcentage de rU+00E9ponse correcte U+00E9tait de [acc]%" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always"
	draw textline 0 170 "Vous pouvez prendre une petite pause" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always"
	draw textline 0 230 "Appuyez une pour continuer" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always"
	draw textline 0 64 "Svp, pour la suite de l'expU+00E9rience" center=1 color=#f57900 font_family="mono" font_size=18 font_italic=no font_bold=yes show_if="=self.get('acc') < self.get('cutoff')"
	draw textline 0 128 "essayez d'obtenir un pourcentage supU+00E9rieur U+00E0 [cutoff]%" center=1 color=#f57900 font_family="mono" font_size=18 font_italic=no font_bold=yes show_if="=self.get('acc') < self.get('cutoff')"

define eyelink_drift_correct eyelink_drift_correct
	set ypos "0"
	set xpos "0"
	set mode "Automatic (fixation triggered)"
	set description "Drift correction plugin for the Eyelink series of eye trackers (SR-Research)"

define keyboard_response ___keyboard_response

define srbox _srbox
	set timeout "infinite"
	set description "Collects input from a serial response box (Psychology Software Tools) or compatible devices"
	set dev "autodetect"
	set _dummy "yes"

define srbox continue_after_practice
	set timeout "infinite"
	set description "Collects input from a serial response box (Psychology Software Tools) or compatible devices"
	set dev "COM4"
	set _dummy "no"

define keyboard_response keyboard_response

define reset_feedback reset_feedback

define keyboard_response _keyboard_response

define text_display goodbye
	set foreground "black"
	set font_size "18"
	set description "Presents a display consisting of text"
	set maxchar "50"
	set align "center"
	__content__
	The experiment is done!
	
	Thank you for participating!
	__end__
	set background "white"
	set duration "keypress"
	set font_family "mono"

define inline_script suppress_warnings
	___run__
	from psychopy import logging
	logging.console.setLevel(logging.CRITICAL)
	__end__
	set _prepare ""
	set description "Executes Python code"

define inline_script global_variables
	set _run ""
	___prepare__
	"""
	DESCRIPTION:
	Here global variables are determined.
	"""
	
	global eyetracking
	eyetracking = True
	
	global language
	language = "French"
	#language = "English"
	
	exp.set("language", language)
	
	# CATCH TRIALS:
	global catch
	catch = False
	exp.set('catch', catch)
	
	
	global large_fix_size, large_fix_col
	large_fix_size = 32
	large_fix_col = "black"
	exp.set("large_fix_size", large_fix_size)
	exp.set("large_fix_col", large_fix_col)
	
	global shown_objects
	shown_objects = []
	
	# FIX CHECK:
	global min_samples_fix, max_dev_fix, min_samples_object, max_dev_object, max_samples, dev_for_warning
	max_samples = 4000 # is 2 seconds?
	min_samples_fix = 50
	max_dev_fix = 25 # in px
	min_samples_object = 50
	max_dev_object = 50
	dev_for_warning = 150
	exp.set("min_samples_fix", min_samples_fix)
	exp.set("min_samples_object", min_samples_object)
	exp.set("max_dev_fix", max_dev_fix)
	exp.set("max_dev_object", max_dev_object)
	exp.set("max_samples", max_samples)
	exp.set("dev_for_warning", dev_for_warning)
	
	
	# CORRECT RESPONSE:
	# Correct response (should be counterbalanced between participants and/ or blocks):
	# Determine participant parity:
	
	global right_button, left_button, right_button_label, left_button_label
	
	left_button = 6
	right_button = 7
	left_button_label = "bouton 1"
	right_button_label = "bouton 2"
	
	pp_parity = self.get("subject_parity")
	
	if pp_parity == "even":
	
		response1 = left_button
		label1 = left_button_label
		response2= right_button
		label2 = right_button_label
		
	elif pp_parity == "odd":
	
		response1 = right_button
		label1 = right_button_label
		response2 = left_button
		label2 = left_button_label
		
	exp.set("response1", response1)
	exp.set("response2", response2)
	exp.set("label1", label1)
	exp.set("label2", label2)
	
	# STIMULUS SIZE:
	
	# Size of the stimulus, depending on whether the object should be scaled or not.
	# Note that w,h, ratio and scale should be floats rather than ints!
	
	global scale_stim, scaled_width, scaled_height
	
	scale_stim = True # set to True to scale the object
	scale = 3.
	
	stim_width_default = 720.
	stim_height_default = 540.
	
	ratio = stim_width_default/ stim_height_default
	
	scaled_width = stim_width_default/scale
	scaled_height = scaled_width/ratio
	
	exp.set("scale_stim", scale_stim)
	exp.set("scale", scale)
	exp.set("scaled_width", scaled_width)
	exp.set("scaled_height", scaled_height)
	
	# COUNTERS:
	global block_total, trials_per_block, nr_catch
	
	# Number of blocks:
	block_total = 6
	exp.set("block_total", block_total)
	
	# Number of trials per block:
	trials_per_block = 108
	exp.set("trials_per_block", trials_per_block)
	
	# Number of catch trials per block:
	nr_catch = 8
	exp.set("nr_catch", nr_catch) 
	
	# CUTOFF:
	# Cutoff for warning message:
	cutoff = 85
	exp.set("cutoff", cutoff)
	
	# COORDINATES:
	
	# The positions are in PsychoPy coordinates, where 0,0 is the center, x<0 is left
	# and y<0 is down.
	
	# Coordinates for fixation are fixed:
	global x_fix, y_fix
	x_fix = 0
	y_fix = 0
	exp.set("y_fix", y_fix)
	
	# The y coordinate for the stimulus should be random within a certain range:
	# TODO: from gaussian with min and max?
	global x_stim, y_stim_min, y_stim_max
	
	# Boundaries vertical eccentricities:
	max_dist = 2 # reasoning behind this being small: undershoot + distance borders
	degrees_min_ecc = 5 # reasoning behind this: parafoveal vision
	degrees_max_ecc = degrees_min_ecc + max_dist 
	
	y_stim_min = toPix(degrees_min_ecc)
	y_stim_max = toPix(degrees_max_ecc)
	
	x_stim = 0 # fixed
	
	print "XXXXXXXXXXXXXXX"
	print "min = ", y_stim_min
	print "max = ",  y_stim_max
	
	# Get y center and y fix in normal coordinates:
	global y_cen, y_fix_normal
	
	y_cen = self.get("height")/2
	y_fix_normal = y_cen + abs(y_fix)
	exp.set("y_cen", y_cen)
	exp.set("y_fix_normal", y_fix_normal)
	
	
	# MASK:
	# The width of the mask. This doesn't change the size of the stimuli, but the
	# resolution of the gradient
	global mask_width
	mask_width = 256
	
	# The minimum and maximum transparency, where -1 is fully transparent and 1 is
	# fully opaque
	global max_transp, min_transp
	max_transp = -1
	min_transp = 1
	
	# DURATION:
	global catch_dur
	feedback_dur = 0
	exp.set("feedback_dur", feedback_dur)
	catch_dur = 6000 # NOTE: in samples
	timeout_dur = 2000
	exp.set("timeout_dur", timeout_dur)
	__end__
	set description "Executes Python code"

define eyelink_calibrate eyelink_calibrate
	set sacc_vel_thresh "35"
	set cal_beep "yes"
	set description "Calibration/ initialization plugin for the Eyelink series of eye trackers (SR-Research)"
	set sacc_acc_thresh "9500"
	set cal_target_size "16"
	set tracker_attached "Yes"

define srbox srbox
	set timeout "[timeout_dur]"
	set description "Collects input from a serial response box (Psychology Software Tools) or compatible devices"
	set dev "COM4"
	set _dummy "no"

